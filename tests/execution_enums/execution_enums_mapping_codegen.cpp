// This file has been auto-generated by the codegen tool
//
// Under **no** circumstances change this file manually as any change will be
// automatically overwritten. Instead change the struct tagged with "codegen::Dictionary"
// or the enum class tagged with "codegen::stringify" in the main file from which he code
// in this file was generated.
//
// If a compiler error brought you into this file, a struct tagged with
// "codegen::Dictionary" or an enum class tagged with "codegen::stringify" was changed
// without the codegen tool being run again.


namespace codegen {
template<typename T> std::string_view toString(T t) { static_assert(sizeof(T) == 0); }
template<typename T> T fromString(std::string_view sv) { static_assert(sizeof(T) == 0); return T(); }

template <> std::string_view toString<Enum1>(Enum1 t) {
    switch (t) { 
        case Enum1::Value1: return "Value1";
        case Enum1::value2: return "value2";
        case Enum1::Value3: return "Value3";
        default: throw "This default label is not necessary since the case labels are "
                       "exhaustive, but not having it makes Visual Studio cranky";
    }
}
template <> Enum1 fromString<Enum1>(std::string_view sv) {
    if (sv == "Value1") { return Enum1::Value1; }
    if (sv == "value2") { return Enum1::value2; }
    if (sv == "Value3") { return Enum1::Value3; }
    throw std::runtime_error("Could not find value in enum");
}

template <> std::string_view toString<Enum2>(Enum2 t) {
    switch (t) { 
        case Enum2::Val4: return "Val4";
        case Enum2::Val5: return "Val5";
        default: throw "This default label is not necessary since the case labels are "
                       "exhaustive, but not having it makes Visual Studio cranky";
    }
}
template <> Enum2 fromString<Enum2>(std::string_view sv) {
    if (sv == "Val4") { return Enum2::Val4; }
    if (sv == "Val5") { return Enum2::Val5; }
    throw std::runtime_error("Could not find value in enum");
}
template<typename T, typename U> T map(U) { static_assert(sizeof(T) == 0); }

template<> Mapped2 map<Mapped2, Enum2>(Enum2 value) {
    switch (value) {
        // If you end up here following a compiler error saying something about 
        // 'illegal qualified name in member declaration' or such nonsense, then you tried
        // to map an enum A to another enum B and A has an enum value that B does not
        // have. For example enum class A { Value1, Value2 }; enum class B { Value1 };
        // would trigger that error on trying to access B::Value2 wich is an illegal
        // qualified name. Make the enums match each other and run codegen again
        case Enum2::Val4:  return Mapped2::Val4;
        case Enum2::Val5:  return Mapped2::Val5;
        default:
            throw "This default label is not necessary since the case labels are "
                  "exhaustive, but not having it makes Visual Studio cranky";
    }
}

template <> std::string_view toString<Enum3>(Enum3 t) {
    switch (t) { 
        case Enum3::Val6: return "Val6";
        default: throw "This default label is not necessary since the case labels are "
                       "exhaustive, but not having it makes Visual Studio cranky";
    }
}
template <> Enum3 fromString<Enum3>(std::string_view sv) {
    if (sv == "Val6") { return Enum3::Val6; }
    throw std::runtime_error("Could not find value in enum");
}

template<> Mapped3 map<Mapped3, Enum3>(Enum3 value) {
    switch (value) {
        // If you end up here following a compiler error saying something about 
        // 'illegal qualified name in member declaration' or such nonsense, then you tried
        // to map an enum A to another enum B and A has an enum value that B does not
        // have. For example enum class A { Value1, Value2 }; enum class B { Value1 };
        // would trigger that error on trying to access B::Value2 wich is an illegal
        // qualified name. Make the enums match each other and run codegen again
        case Enum3::Val6:  return Mapped3::Val6;
        default:
            throw "This default label is not necessary since the case labels are "
                  "exhaustive, but not having it makes Visual Studio cranky";
    }
}
}// namespace codegen

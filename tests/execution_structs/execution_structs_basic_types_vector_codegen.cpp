// This file has been auto-generated by the codegen tool
//
// Under **no** circumstances change this file manually as any change will be
// automatically overwritten. Instead change the struct tagged with "codegen::Dictionary"
// or the enum class tagged with "codegen::stringify" in the main file from which he code
// in this file was generated.
//
// If a compiler error brought you into this file, a struct tagged with
// "codegen::Dictionary" or an enum class tagged with "codegen::stringify" was changed
// without the codegen tool being run again.

namespace codegen {
template<typename T> openspace::documentation::Documentation doc(std::string) {
    static_assert(sizeof(T) == 0);
    return openspace::documentation::Documentation();
}
template <> openspace::documentation::Documentation doc<Parameters>(std::string id) {
    using namespace openspace::documentation;

    TableVerifier codegen_Parameters_content;
    TableVerifier* codegen_Parameters = &codegen_Parameters_content;
    codegen_Parameters->documentations.push_back({"BoolValue",new TableVerifier({{"*",new BoolVerifier,Optional::Yes, }})
,Optional::No,"bool value documentation"});
    codegen_Parameters->documentations.push_back({"IntValue",new TableVerifier({{"*",new IntVerifier,Optional::Yes, }})
,Optional::No,"int value documentation"});
    codegen_Parameters->documentations.push_back({"DoubleValue",new TableVerifier({{"*",new DoubleVerifier,Optional::Yes, }})
,Optional::No,"double value documentation"});
    codegen_Parameters->documentations.push_back({"FloatValue",new TableVerifier({{"*",new DoubleVerifier,Optional::Yes, }})
,Optional::No,"float value documentation"});
    codegen_Parameters->documentations.push_back({"StringValue",new TableVerifier({{"*",new StringVerifier,Optional::Yes, }})
,Optional::No,"string value documentation"});
    codegen_Parameters->documentations.push_back({"StringNotEmptyValue",new TableVerifier({{"*",new StringVerifier(true),Optional::Yes, }})
,Optional::No,"string not empty value documentation"});
    codegen_Parameters->documentations.push_back({"PathValue",new TableVerifier({{"*",new FileVerifier,Optional::Yes, }})
,Optional::No,"path value documentation"});
    codegen_Parameters->documentations.push_back({"DirectoryValue",new TableVerifier({{"*",new DirectoryVerifier,Optional::Yes, }})
,Optional::No,"directory value documentation"});
    codegen_Parameters->documentations.push_back({"Ivec2Value",new TableVerifier({{"*",new IntVector2Verifier,Optional::Yes, }})
,Optional::No,"ivec2 value documentation"});
    codegen_Parameters->documentations.push_back({"Ivec3Value",new TableVerifier({{"*",new IntVector3Verifier,Optional::Yes, }})
,Optional::No,"ivec3 value documentation"});
    codegen_Parameters->documentations.push_back({"Ivec4Value",new TableVerifier({{"*",new IntVector4Verifier,Optional::Yes, }})
,Optional::No,"ivec4 value documentation"});
    codegen_Parameters->documentations.push_back({"Dvec2Value",new TableVerifier({{"*",new DoubleVector2Verifier,Optional::Yes, }})
,Optional::No,"dvec2 value documentation"});
    codegen_Parameters->documentations.push_back({"Dvec3Value",new TableVerifier({{"*",new DoubleVector3Verifier,Optional::Yes, }})
,Optional::No,"dvec3 value documentation"});
    codegen_Parameters->documentations.push_back({"Dvec4Value",new TableVerifier({{"*",new DoubleVector4Verifier,Optional::Yes, }})
,Optional::No,"dvec4 value documentation"});
    codegen_Parameters->documentations.push_back({"Vec2Value",new TableVerifier({{"*",new DoubleVector2Verifier,Optional::Yes, }})
,Optional::No,"vec2 value documentation"});
    codegen_Parameters->documentations.push_back({"Vec3Value",new TableVerifier({{"*",new DoubleVector3Verifier,Optional::Yes, }})
,Optional::No,"vec3 value documentation"});
    codegen_Parameters->documentations.push_back({"Vec4Value",new TableVerifier({{"*",new DoubleVector4Verifier,Optional::Yes, }})
,Optional::No,"vec4 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat2x2Value",new TableVerifier({{"*",new DoubleMatrix2x2Verifier,Optional::Yes, }})
,Optional::No,"mat2x2 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat2Value",new TableVerifier({{"*",new DoubleMatrix2x2Verifier,Optional::Yes, }})
,Optional::No,"mat2 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat2x3Value",new TableVerifier({{"*",new DoubleMatrix2x3Verifier,Optional::Yes, }})
,Optional::No,"mat2x3 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat2x4Value",new TableVerifier({{"*",new DoubleMatrix2x4Verifier,Optional::Yes, }})
,Optional::No,"mat2x4 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat3x2Value",new TableVerifier({{"*",new DoubleMatrix3x2Verifier,Optional::Yes, }})
,Optional::No,"mat3x2 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat3x3Value",new TableVerifier({{"*",new DoubleMatrix3x3Verifier,Optional::Yes, }})
,Optional::No,"mat3x3 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat3Value",new TableVerifier({{"*",new DoubleMatrix3x3Verifier,Optional::Yes, }})
,Optional::No,"mat3 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat3x4Value",new TableVerifier({{"*",new DoubleMatrix3x4Verifier,Optional::Yes, }})
,Optional::No,"mat3x4 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat4x2Value",new TableVerifier({{"*",new DoubleMatrix4x2Verifier,Optional::Yes, }})
,Optional::No,"mat4x2 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat4x3Value",new TableVerifier({{"*",new DoubleMatrix4x3Verifier,Optional::Yes, }})
,Optional::No,"mat4x3 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat4x4Value",new TableVerifier({{"*",new DoubleMatrix4x4Verifier,Optional::Yes, }})
,Optional::No,"mat4x4 value documentation"});
    codegen_Parameters->documentations.push_back({"Mat4Value",new TableVerifier({{"*",new DoubleMatrix4x4Verifier,Optional::Yes, }})
,Optional::No,"mat4 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat2x2Value",new TableVerifier({{"*",new DoubleMatrix2x2Verifier,Optional::Yes, }})
,Optional::No,"dmat2x2 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat2Value",new TableVerifier({{"*",new DoubleMatrix2x2Verifier,Optional::Yes, }})
,Optional::No,"dmat2 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat2x3Value",new TableVerifier({{"*",new DoubleMatrix2x3Verifier,Optional::Yes, }})
,Optional::No,"dmat2x3 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat2x4Value",new TableVerifier({{"*",new DoubleMatrix2x4Verifier,Optional::Yes, }})
,Optional::No,"dmat2x4 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat3x2Value",new TableVerifier({{"*",new DoubleMatrix3x2Verifier,Optional::Yes, }})
,Optional::No,"dmat3x2 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat3x3Value",new TableVerifier({{"*",new DoubleMatrix3x3Verifier,Optional::Yes, }})
,Optional::No,"dmat3x3 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat3Value",new TableVerifier({{"*",new DoubleMatrix3x3Verifier,Optional::Yes, }})
,Optional::No,"dmat3 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat3x4Value",new TableVerifier({{"*",new DoubleMatrix3x4Verifier,Optional::Yes, }})
,Optional::No,"dmat3x4 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat4x2Value",new TableVerifier({{"*",new DoubleMatrix4x2Verifier,Optional::Yes, }})
,Optional::No,"dmat4x2 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat4x3Value",new TableVerifier({{"*",new DoubleMatrix4x3Verifier,Optional::Yes, }})
,Optional::No,"dmat4x3 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat4x4Value",new TableVerifier({{"*",new DoubleMatrix4x4Verifier,Optional::Yes, }})
,Optional::No,"dmat4x4 value documentation"});
    codegen_Parameters->documentations.push_back({"Dmat4Value",new TableVerifier({{"*",new DoubleMatrix4x4Verifier,Optional::Yes, }})
,Optional::No,"dmat4 value documentation"});
    codegen_Parameters->documentations.push_back({"DictValue",new TableVerifier({{"*",new TableVerifier,Optional::Yes, }})
,Optional::No,"dict value documentation"});

    openspace::documentation::Documentation d = { "BasicTypesVector", std::move(id), std::move(codegen_Parameters->documentations) };
    return d;
}

} // namespace codegen

namespace codegen {
namespace internal { 
template<typename T> void bakeTo(const ghoul::Dictionary&, std::string_view, T*) { static_assert(sizeof(T) == 0); }
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val);
void bakeTo(const ghoul::Dictionary& d, std::string_view key, bool* val) { *val = d.value<bool>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, int* val) { if (d.hasValue<double>(key)) { *val = static_cast<int>(d.value<double>(key)); } else if (d.hasValue<int>(key)) { *val = d.value<int>(key); } else { throw std::logic_error("Unexpected type"); } }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, double* val) { *val = d.value<double>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, float* val) { *val = static_cast<float>(d.value<double>(key)); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::string* val) { *val = d.value<std::string>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::filesystem::path* val) { *val = d.value<std::string>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::ivec2* val) { *val = d.value<glm::dvec2>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::ivec3* val) { *val = d.value<glm::dvec3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::ivec4* val) { *val = d.value<glm::dvec4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dvec2* val) { *val = d.value<glm::dvec2>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dvec3* val) { *val = d.value<glm::dvec3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dvec4* val) { *val = d.value<glm::dvec4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::vec2* val) { *val = d.value<glm::dvec2>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::vec3* val) { *val = d.value<glm::dvec3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::vec4* val) { *val = d.value<glm::dvec4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::mat2x2* val) { *val = d.value<glm::dmat2x2>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::mat2x3* val) { *val = d.value<glm::dmat2x3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::mat2x4* val) { *val = d.value<glm::dmat2x4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::mat3x2* val) { *val = d.value<glm::dmat3x2>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::mat3x3* val) { *val = d.value<glm::dmat3x3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::mat3x4* val) { *val = d.value<glm::dmat3x4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::mat4x2* val) { *val = d.value<glm::dmat4x2>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::mat4x3* val) { *val = d.value<glm::dmat4x3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::mat4x4* val) { *val = d.value<glm::dmat4x4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat2x2* val) { *val = d.value<glm::dmat2x2>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat2x3* val) { *val = d.value<glm::dmat2x3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat2x4* val) { *val = d.value<glm::dmat2x4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat3x2* val) { *val = d.value<glm::dmat3x2>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat3x3* val) { *val = d.value<glm::dmat3x3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat3x4* val) { *val = d.value<glm::dmat3x4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat4x2* val) { *val = d.value<glm::dmat4x2>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat4x3* val) { *val = d.value<glm::dmat4x3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dmat4x4* val) { *val = d.value<glm::dmat4x4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, ghoul::Dictionary* val) { *val = d.value<ghoul::Dictionary>(key); }

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val) {
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    // For the moment we need to make sure in here that all of the keys are sequential
    // since our TableVerifier doesn't really do that and we don't have a VectorVerifier
    // for a flat list (yet).  So you might have gotten a specification error from here
    // iff the Dictionary that was passed in contained keys other than a linear sequence
    // from 1 - dict.size()  [1 because Lua for some strange reason wants to start at the
    // wrong number]

    for (size_t i = 1; i <= dict.size(); ++i) {
        std::string k = std::to_string(i);
        if (!dict.hasKey(k)) {
            throw std::runtime_error("Could not find key '" + k + "' in the dictionary");
        }
    }    

    for (size_t i = 1; i <= dict.size(); ++i) {
        T v;
        bakeTo(dict, std::to_string(i), &v);
        val->push_back(std::move(v));
    }
}

} // namespace internal

template <typename T> T bake(const ghoul::Dictionary&) { static_assert(sizeof(T) == 0); }

template <> Parameters bake<Parameters>(const ghoul::Dictionary& dict) {
    openspace::documentation::testSpecificationAndThrow(codegen::doc<Parameters>("Parameters"), dict, "BasicTypesVector");
    Parameters res;
    internal::bakeTo(dict, "BoolValue", &res.boolValue);
    internal::bakeTo(dict, "IntValue", &res.intValue);
    internal::bakeTo(dict, "DoubleValue", &res.doubleValue);
    internal::bakeTo(dict, "FloatValue", &res.floatValue);
    internal::bakeTo(dict, "StringValue", &res.stringValue);
    internal::bakeTo(dict, "StringNotEmptyValue", &res.stringNotEmptyValue);
    internal::bakeTo(dict, "PathValue", &res.pathValue);
    internal::bakeTo(dict, "DirectoryValue", &res.directoryValue);
    internal::bakeTo(dict, "Ivec2Value", &res.ivec2Value);
    internal::bakeTo(dict, "Ivec3Value", &res.ivec3Value);
    internal::bakeTo(dict, "Ivec4Value", &res.ivec4Value);
    internal::bakeTo(dict, "Dvec2Value", &res.dvec2Value);
    internal::bakeTo(dict, "Dvec3Value", &res.dvec3Value);
    internal::bakeTo(dict, "Dvec4Value", &res.dvec4Value);
    internal::bakeTo(dict, "Vec2Value", &res.vec2Value);
    internal::bakeTo(dict, "Vec3Value", &res.vec3Value);
    internal::bakeTo(dict, "Vec4Value", &res.vec4Value);
    internal::bakeTo(dict, "Mat2x2Value", &res.mat2x2Value);
    internal::bakeTo(dict, "Mat2Value", &res.mat2Value);
    internal::bakeTo(dict, "Mat2x3Value", &res.mat2x3Value);
    internal::bakeTo(dict, "Mat2x4Value", &res.mat2x4Value);
    internal::bakeTo(dict, "Mat3x2Value", &res.mat3x2Value);
    internal::bakeTo(dict, "Mat3x3Value", &res.mat3x3Value);
    internal::bakeTo(dict, "Mat3Value", &res.mat3Value);
    internal::bakeTo(dict, "Mat3x4Value", &res.mat3x4Value);
    internal::bakeTo(dict, "Mat4x2Value", &res.mat4x2Value);
    internal::bakeTo(dict, "Mat4x3Value", &res.mat4x3Value);
    internal::bakeTo(dict, "Mat4x4Value", &res.mat4x4Value);
    internal::bakeTo(dict, "Mat4Value", &res.mat4Value);
    internal::bakeTo(dict, "Dmat2x2Value", &res.dmat2x2Value);
    internal::bakeTo(dict, "Dmat2Value", &res.dmat2Value);
    internal::bakeTo(dict, "Dmat2x3Value", &res.dmat2x3Value);
    internal::bakeTo(dict, "Dmat2x4Value", &res.dmat2x4Value);
    internal::bakeTo(dict, "Dmat3x2Value", &res.dmat3x2Value);
    internal::bakeTo(dict, "Dmat3x3Value", &res.dmat3x3Value);
    internal::bakeTo(dict, "Dmat3Value", &res.dmat3Value);
    internal::bakeTo(dict, "Dmat3x4Value", &res.dmat3x4Value);
    internal::bakeTo(dict, "Dmat4x2Value", &res.dmat4x2Value);
    internal::bakeTo(dict, "Dmat4x3Value", &res.dmat4x3Value);
    internal::bakeTo(dict, "Dmat4x4Value", &res.dmat4x4Value);
    internal::bakeTo(dict, "Dmat4Value", &res.dmat4Value);
    internal::bakeTo(dict, "DictValue", &res.dictValue);
    return res;
}

}// namespace codegen

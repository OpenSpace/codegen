// This file has been auto-generated by the codegen tool
//
// Under **no** circumstances change this file manually as any change will be
// automatically overwritten. Instead change the struct tagged with "codegen::Dictionary"
// or the enum class tagged with "codegen::stringify" in the main file from which he code
// in this file was generated.
//
// If a compiler error brought you into this file, a struct tagged with
// "codegen::Dictionary" or an enum class tagged with "codegen::stringify" was changed
// without the codegen tool being run again.

namespace codegen {
template<typename T> openspace::documentation::Documentation doc(std::string) {
    static_assert(sizeof(T) == 0);
    return openspace::documentation::Documentation();
}
template <> openspace::documentation::Documentation doc<Parameters1>(std::string id) {
    using namespace openspace::documentation;

    TableVerifier codegen_Parameters1_content;
    TableVerifier* codegen_Parameters1 = &codegen_Parameters1_content;
    codegen_Parameters1->documentations.push_back({"Abc",new IntVerifier,Optional::No,""});

    openspace::documentation::Documentation d = { "D1", std::move(id), std::move(codegen_Parameters1->documentations) };
    return d;
}


template <> openspace::documentation::Documentation doc<Parameters2>(std::string id) {
    using namespace openspace::documentation;

    TableVerifier codegen_Parameters2_content;
    TableVerifier* codegen_Parameters2 = &codegen_Parameters2_content;
    codegen_Parameters2->documentations.push_back({"Def",new IntVerifier,Optional::No,""});

    openspace::documentation::Documentation d = { "D2", std::move(id), std::move(codegen_Parameters2->documentations) };
    return d;
}

} // namespace codegen

namespace codegen {
namespace internal { 
template<typename T> void bakeTo(const ghoul::Dictionary&, std::string_view, T*) { static_assert(sizeof(T) == 0); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, int* val) { if (d.hasValue<double>(key)) { *val = static_cast<int>(d.value<double>(key)); } else if (d.hasValue<int>(key)) { *val = d.value<int>(key); } else { throw std::logic_error("Unexpected type"); } }

} // namespace internal

template <typename T> T bake(const ghoul::Dictionary&) { static_assert(sizeof(T) == 0); }

template <> Parameters1 bake<Parameters1>(const ghoul::Dictionary& dict) {
    openspace::documentation::testSpecificationAndThrow(codegen::doc<Parameters1>("Parameters1"), dict, "D1");
    Parameters1 res;
    internal::bakeTo(dict, "Abc", &res.abc);
    return res;
}

template <> Parameters2 bake<Parameters2>(const ghoul::Dictionary& dict) {
    openspace::documentation::testSpecificationAndThrow(codegen::doc<Parameters2>("Parameters2"), dict, "D2");
    Parameters2 res;
    internal::bakeTo(dict, "Def", &res.def);
    return res;
}

}// namespace codegen

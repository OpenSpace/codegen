// This file has been auto-generated by the codegen tool
//
// Under **no** circumstances change this file manually as any change will be
// automatically overwritten. Instead change the struct tagged with "codegen::Dictionary"
// or the enum class tagged with "codegen::stringify" in the main file from which he code
// in this file was generated.
//
// If a compiler error brought you into this file, a struct tagged with
// "codegen::Dictionary" or an enum class tagged with "codegen::stringify" was changed
// without the codegen tool being run again.

namespace codegen {
template<typename T> openspace::documentation::Documentation doc(std::string) {
    static_assert(sizeof(T) == 0);
    return openspace::documentation::Documentation();
}
template <> openspace::documentation::Documentation doc<Parameters>(std::string id) {
    using namespace openspace::documentation;

    TableVerifier codegen_Parameters_content;
    TableVerifier* codegen_Parameters = &codegen_Parameters_content;
    std::shared_ptr<StringInListVerifier> codegen_Parameters_A = std::make_shared<StringInListVerifier>(std::vector<std::string>{"Value1","value2","Value3"});
    codegen_Parameters->documentations.push_back({"EnumAValue",codegen_Parameters_A,Optional::No,"variable enumAValue documentation"});

    openspace::documentation::Documentation d = { "EnumMapping", std::move(id), std::move(codegen_Parameters->documentations) };
    return d;
}

} // namespace codegen

namespace codegen {
namespace internal { 
template<typename T> void bakeTo(const ghoul::Dictionary&, std::string_view, T*) { static_assert(sizeof(T) == 0); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, Parameters::A* val) {
    std::string v = d.value<std::string>(key);
    if (v == "Value1") { *val = Parameters::A::Value1; }
    if (v == "value2") { *val = Parameters::A::value2; }
    if (v == "Value3") { *val = Parameters::A::Value3; }
}

} // namespace internal

template <typename T> T bake(const ghoul::Dictionary&) { static_assert(sizeof(T) == 0); }

template <> Parameters bake<Parameters>(const ghoul::Dictionary& dict) {
    openspace::documentation::testSpecificationAndThrow(codegen::doc<Parameters>("Parameters"), dict, "EnumMapping");
    Parameters res;
    internal::bakeTo(dict, "EnumAValue", &res.enumAValue);
    return res;
}
template<typename T, typename U> T map(U) { static_assert(sizeof(T) == 0); }

template<> MappedEnumA map<MappedEnumA, Parameters::A>(Parameters::A value) {
    switch (value) {
        // If you end up here following a compiler error saying something about 
        // 'illegal qualified name in member declaration' or such nonsense, then you tried
        // to map an enum A to another enum B and A has an enum value that B does not
        // have. For example enum class A { Value1, Value2 }; enum class B { Value1 };
        // would trigger that error on trying to access B::Value2 wich is an illegal
        // qualified name. Make the enums match each other and run codegen again
        case Parameters::A::Value1:  return MappedEnumA::Value1;
        case Parameters::A::value2:  return MappedEnumA::value2;
        case Parameters::A::Value3:  return MappedEnumA::Value3;
        default:
            throw "This default label is not necessary since the case labels are "
                  "exhaustive, but not having it makes Visual Studio cranky";
    }
}

}// namespace codegen

// This file has been auto-generated by the codegen tool
//
// Do not change this file manually as any change will be automatically overwritten,
// instead change the struct tagged with "codegen::Dictionary" in the main file from which
// the code in this file was generated.
//
// If a compiler error brought you here, a struct tagged with "codegen::Dictionary"
// was changed without the codegen tool being run again.
namespace codegen {
template<typename T> openspace::documentation::Documentation doc(std::string) {
    static_assert(sizeof(T) == 0);
    return openspace::documentation::Documentation();
}
template <> openspace::documentation::Documentation doc<Parameters>(std::string id) {
    using namespace openspace::documentation;

    TableVerifier codegen_Parameters_content;
    TableVerifier* codegen_Parameters = &codegen_Parameters_content;
    codegen_Parameters->documentations.push_back({"KeyKey",new DoubleVerifier,Optional::No,"keyValue documentation"});
    codegen_Parameters->documentations.push_back({"KeyKeyOptional",new DoubleVerifier,Optional::Yes,"keyValueOptional documentation"});
    codegen_Parameters->documentations.push_back({"KeyKeyVector",new TableVerifier({{"*",new DoubleVerifier,Optional::Yes, }})
,Optional::No,"keyValueVector documentation"});
    codegen_Parameters->documentations.push_back({"InRangeValueInt",new InRangeVerifier<IntVerifier>(-2, 8),Optional::No,"inRangeValueInt documentation"});
    codegen_Parameters->documentations.push_back({"InRangeValueIntOptional",new InRangeVerifier<IntVerifier>(-2, 8),Optional::Yes,"inRangeValueIntOptional documentation"});
    codegen_Parameters->documentations.push_back({"InRangeValueIntVector",new TableVerifier({{"*",new InRangeVerifier<IntVerifier>(-2, 8),Optional::Yes, }})
,Optional::No,"inRangeValueIntVector documentation"});
    codegen_Parameters->documentations.push_back({"InRangeValueFloat",new InRangeVerifier<DoubleVerifier>(8.0, 9.0),Optional::No,"inRangeValueFloat documentation"});
    codegen_Parameters->documentations.push_back({"InRangeValueFloatOptional",new InRangeVerifier<DoubleVerifier>(8.0, 9.0),Optional::Yes,"inRangeValueFloatOptional documentation"});
    codegen_Parameters->documentations.push_back({"InRangeValueFloatVector",new TableVerifier({{"*",new InRangeVerifier<DoubleVerifier>(8.0, 9.0),Optional::Yes, }})
,Optional::No,"inRangeValueFloatVector documentation"});
    codegen_Parameters->documentations.push_back({"NotInRangeValueInt",new NotInRangeVerifier<IntVerifier>(5, 7),Optional::No,"notInRangeValueInt documentation"});
    codegen_Parameters->documentations.push_back({"NotInRangeValueIntOptional",new NotInRangeVerifier<IntVerifier>(5, 7),Optional::Yes,"notInRangeValueIntOptional documentation"});
    codegen_Parameters->documentations.push_back({"NotInRangeValueIntVector",new TableVerifier({{"*",new NotInRangeVerifier<IntVerifier>(5, 7),Optional::Yes, }})
,Optional::No,"notInRangeValueIntVector documentation"});
    codegen_Parameters->documentations.push_back({"NotInRangeValueFloat",new NotInRangeVerifier<DoubleVerifier>(-0.5, 0.5),Optional::No,"notInRangeValueFloat documentation"});
    codegen_Parameters->documentations.push_back({"NotInRangeValueFloatOptional",new NotInRangeVerifier<DoubleVerifier>(-0.5, 0.5),Optional::Yes,"notInRangeValueFloatOptional documentation"});
    codegen_Parameters->documentations.push_back({"NotInRangeValueFloatVector",new TableVerifier({{"*",new NotInRangeVerifier<DoubleVerifier>(-0.5, 0.5),Optional::Yes, }})
,Optional::No,"notInRangeValueFloatVector documentation"});
    codegen_Parameters->documentations.push_back({"LessValueInt",new LessVerifier<IntVerifier>(20),Optional::No,"lessValueInt documentation"});
    codegen_Parameters->documentations.push_back({"LessValueIntOptional",new LessVerifier<IntVerifier>(20),Optional::Yes,"lessValueIntOptional documentation"});
    codegen_Parameters->documentations.push_back({"LessValueIntVector",new TableVerifier({{"*",new LessVerifier<IntVerifier>(20),Optional::Yes, }})
,Optional::No,"lessValueIntVector documentation"});
    codegen_Parameters->documentations.push_back({"LessValueFloat",new LessVerifier<DoubleVerifier>(21.0),Optional::No,"lessValueFloat documentation"});
    codegen_Parameters->documentations.push_back({"LessValueFloatOptional",new LessVerifier<DoubleVerifier>(22.0),Optional::Yes,"lessValueFloatOptional documentation"});
    codegen_Parameters->documentations.push_back({"LessValueFloatVector",new TableVerifier({{"*",new LessVerifier<DoubleVerifier>(23.0),Optional::Yes, }})
,Optional::No,"lessValueFloatVector documentation"});
    codegen_Parameters->documentations.push_back({"LessEqualValueInt",new LessEqualVerifier<IntVerifier>(25),Optional::No,"lessEqualValueInt documentation"});
    codegen_Parameters->documentations.push_back({"LessEqualValueIntOptional",new LessEqualVerifier<IntVerifier>(25),Optional::Yes,"lessEqualValueIntOptional documentation"});
    codegen_Parameters->documentations.push_back({"LessEqualValueIntVector",new TableVerifier({{"*",new LessEqualVerifier<IntVerifier>(25),Optional::Yes, }})
,Optional::No,"lessEqualValueIntVector documentation"});
    codegen_Parameters->documentations.push_back({"LessEqualValueFloat",new LessEqualVerifier<DoubleVerifier>(27.0),Optional::No,"lessEqualValueFloat documentation"});
    codegen_Parameters->documentations.push_back({"LessEqualValueFloatOptional",new LessEqualVerifier<DoubleVerifier>(27.0),Optional::Yes,"lessEqualValueFloatOptional documentation"});
    codegen_Parameters->documentations.push_back({"LessEqualValueFloatVector",new TableVerifier({{"*",new LessEqualVerifier<DoubleVerifier>(27.0),Optional::Yes, }})
,Optional::No,"lessEqualValueFloatVector documentation"});
    codegen_Parameters->documentations.push_back({"GreaterValueInt",new GreaterVerifier<IntVerifier>(25),Optional::No,"greaterValueInt documentation"});
    codegen_Parameters->documentations.push_back({"GreaterValueIntOptional",new GreaterVerifier<IntVerifier>(25),Optional::Yes,"greaterValueIntOptional documentation"});
    codegen_Parameters->documentations.push_back({"GreaterValueIntVector",new TableVerifier({{"*",new GreaterVerifier<IntVerifier>(25),Optional::Yes, }})
,Optional::No,"greaterValueIntVector documentation"});
    codegen_Parameters->documentations.push_back({"GreaterValueFloat",new GreaterVerifier<DoubleVerifier>(-5.0),Optional::No,"greaterValueFloat documentation"});
    codegen_Parameters->documentations.push_back({"GreaterValueFloatOptional",new GreaterVerifier<DoubleVerifier>(-5.0),Optional::Yes,"greaterValueFloatOptional documentation"});
    codegen_Parameters->documentations.push_back({"GreaterValueFloatVector",new TableVerifier({{"*",new GreaterVerifier<DoubleVerifier>(-5.0),Optional::Yes, }})
,Optional::No,"greaterValueFloatVector documentation"});
    codegen_Parameters->documentations.push_back({"GreaterEqualValueInt",new GreaterEqualVerifier<IntVerifier>(33),Optional::No,"greaterEqualValueInt documentation"});
    codegen_Parameters->documentations.push_back({"GreaterEqualValueIntOptional",new GreaterEqualVerifier<IntVerifier>(33),Optional::Yes,"greaterEqualValueIntOptional documentation"});
    codegen_Parameters->documentations.push_back({"GreaterEqualValueIntVector",new TableVerifier({{"*",new GreaterEqualVerifier<IntVerifier>(33),Optional::Yes, }})
,Optional::No,"greaterEqualValueIntVector documentation"});
    codegen_Parameters->documentations.push_back({"GreaterEqualValueFloat",new GreaterEqualVerifier<DoubleVerifier>(-25.0),Optional::No,"greaterEqualValueFloat documentation"});
    codegen_Parameters->documentations.push_back({"GreaterEqualValueFloatOptional",new GreaterEqualVerifier<DoubleVerifier>(-25.0),Optional::Yes,"greaterEqualValueFloatOptional documentation"});
    codegen_Parameters->documentations.push_back({"GreaterEqualValueFloatVector",new TableVerifier({{"*",new GreaterEqualVerifier<DoubleVerifier>(-25.0),Optional::Yes, }})
,Optional::No,"greaterEqualValueFloatVector documentation"});
    codegen_Parameters->documentations.push_back({"UnequalValueInt",new UnequalVerifier<IntVerifier>(1),Optional::No,"unequalValueInt documentation"});
    codegen_Parameters->documentations.push_back({"UnequalValueIntOptional",new UnequalVerifier<IntVerifier>(1),Optional::Yes,"unequalValueIntOptional documentation"});
    codegen_Parameters->documentations.push_back({"UnequalValueIntVector",new TableVerifier({{"*",new UnequalVerifier<IntVerifier>(1),Optional::Yes, }})
,Optional::No,"unequalValueIntVector documentation"});
    codegen_Parameters->documentations.push_back({"UnequalValueFloat",new UnequalVerifier<DoubleVerifier>(123.0),Optional::No,"unequalValueFloat documentation"});
    codegen_Parameters->documentations.push_back({"UnequalValueFloatOptional",new UnequalVerifier<DoubleVerifier>(123.0),Optional::Yes,"unequalValueFloatOptional documentation"});
    codegen_Parameters->documentations.push_back({"UnequalValueFloatVector",new TableVerifier({{"*",new UnequalVerifier<DoubleVerifier>(123.0),Optional::Yes, }})
,Optional::No,"unequalValueFloatVector documentation"});
    codegen_Parameters->documentations.push_back({"DescValue",new BoolVerifier,Optional::No,description});
    codegen_Parameters->documentations.push_back({"InListValue1",new InListVerifier<StringVerifier>({"A", "B", "C", "D", "E"}),Optional::No,"inListValue1 documentation"});
    codegen_Parameters->documentations.push_back({"InListValue1Optional",new InListVerifier<StringVerifier>({"A", "B", "C", "D", "E"}),Optional::Yes,"inListValue1Optional documentation"});
    codegen_Parameters->documentations.push_back({"InListValue1Vector",new TableVerifier({{"*",new InListVerifier<StringVerifier>({"A", "B", "C", "D", "E"}),Optional::Yes, }})
,Optional::No,"inListValue1Vector documentation"});
    codegen_Parameters->documentations.push_back({"InListValue2",new InListVerifier<StringVerifier>({List}),Optional::No,"inListValue2 documentation"});
    codegen_Parameters->documentations.push_back({"InListValue2Optional",new InListVerifier<StringVerifier>({List}),Optional::Yes,"inListValue2Optional documentation"});
    codegen_Parameters->documentations.push_back({"InListValue2Vector",new TableVerifier({{"*",new InListVerifier<StringVerifier>({List}),Optional::Yes, }})
,Optional::No,"inListValue2Vector documentation"});
    codegen_Parameters->documentations.push_back({"UnequalValueString",new UnequalVerifier<StringVerifier>("abcdef"),Optional::No,"unequalValueString documentation"});
    codegen_Parameters->documentations.push_back({"UnequalValueStringOptional",new UnequalVerifier<StringVerifier>("abcdef"),Optional::Yes,"unequalValueStringOptional documentation"});
    codegen_Parameters->documentations.push_back({"UnequalValueStringVector",new TableVerifier({{"*",new UnequalVerifier<StringVerifier>("abcdef"),Optional::Yes, }})
,Optional::No,"unequalValueStringVector documentation"});
    codegen_Parameters->documentations.push_back({"NotEmptyString",new StringVerifier(true),Optional::No,"string not empty value documentation"});
    codegen_Parameters->documentations.push_back({"NotEmptyStringOptional",new StringVerifier(true),Optional::Yes,"string not empty optional value documentation"});
    codegen_Parameters->documentations.push_back({"NotEmptyStringVector",new TableVerifier({{"*",new StringVerifier(true),Optional::Yes, }})
,Optional::No,"string not empty vector value documentation"});
    codegen_Parameters->documentations.push_back({"NotEmptyStringOptionalVector",new TableVerifier({{"*",new StringVerifier(true),Optional::Yes, }})
,Optional::Yes,"string not empty optional vector value documentation"});
    codegen_Parameters->documentations.push_back({"ReferenceValueOptional",new ReferencingVerifier("abc"),Optional::Yes,"referenceValueOptional documentation"});
    codegen_Parameters->documentations.push_back({"ReferenceValueVector",new TableVerifier({{"*",new ReferencingVerifier("abc"),Optional::Yes, }})
,Optional::Yes,"referenceValueVector documentation"});
    codegen_Parameters->documentations.push_back({"DictValue",new ReferencingVerifier("abc"),Optional::No,"dictValue documentation"});
    codegen_Parameters->documentations.push_back({"DictValueVector",new TableVerifier({{"*",new ReferencingVerifier("abc"),Optional::Yes, }})
,Optional::No,"dictValueVector documentation"});
    codegen_Parameters->documentations.push_back({"DictValueOptional",new ReferencingVerifier("abc"),Optional::Yes,"dictValueOptional documentation"});
    codegen_Parameters->documentations.push_back({"DictValueMap",new TableVerifier({{"*", new ReferencingVerifier("abc"), Optional::No }})
,Optional::No,"dictValueMap documentation"});
    codegen_Parameters->documentations.push_back({"VectorDictValueMap",new TableVerifier({{"*",new TableVerifier({{"*", new ReferencingVerifier("abc"), Optional::No }})
,Optional::Yes, }})
,Optional::No,"vectorDictValueMap documentation"});
    codegen_Parameters->documentations.push_back({"OptionalDictValueMap",new TableVerifier({{"*", new ReferencingVerifier("abc"), Optional::No }})
,Optional::Yes,"optionalDictValueMap documentation"});
    codegen_Parameters->documentations.push_back({"OptionalVectorDictValueMap",new TableVerifier({{"*",new TableVerifier({{"*", new ReferencingVerifier("abc"), Optional::No }})
,Optional::Yes, }})
,Optional::Yes,"optionalVectorDictValueMap documentation"});
    codegen_Parameters->documentations.push_back({"Annotation",new AnnotationVerifier<StringVerifier>("abc"),Optional::No,"annotation documentation"});
    codegen_Parameters->documentations.push_back({"AnnotationOptional",new AnnotationVerifier<StringVerifier>("def"),Optional::Yes,"annotationOptional documentation"});
    codegen_Parameters->documentations.push_back({"AnnotationVector",new TableVerifier({{"*",new AnnotationVerifier<StringVerifier>("ghi"),Optional::Yes, }})
,Optional::No,"annotationVector documentation"});
    codegen_Parameters->documentations.push_back({"Dcolor3Value",new Color3Verifier,Optional::No,"dcolor3Value documentation"});
    codegen_Parameters->documentations.push_back({"OptionalDcolor3Value",new Color3Verifier,Optional::Yes,"optionalDcolor3Value documentation"});
    codegen_Parameters->documentations.push_back({"VectorDcolor3Value",new TableVerifier({{"*",new Color3Verifier,Optional::Yes, }})
,Optional::No,"vectorDcolor3Value documentation"});
    codegen_Parameters->documentations.push_back({"Color3Value",new Color3Verifier,Optional::No,"color3Value documentation"});
    codegen_Parameters->documentations.push_back({"OptionalColor3Value",new Color3Verifier,Optional::Yes,"optionalColor3Value documentation"});
    codegen_Parameters->documentations.push_back({"VectorColor3Value",new TableVerifier({{"*",new Color3Verifier,Optional::Yes, }})
,Optional::No,"vectorColor3Value documentation"});
    codegen_Parameters->documentations.push_back({"Dcolor4Value",new Color4Verifier,Optional::No,"dcolor4Value documentation"});
    codegen_Parameters->documentations.push_back({"OptionalDcolor4Value",new Color4Verifier,Optional::Yes,"optionalDcolor4Value documentation"});
    codegen_Parameters->documentations.push_back({"VectorDcolor4Value",new TableVerifier({{"*",new Color4Verifier,Optional::Yes, }})
,Optional::No,"vectorDcolor4Value documentation"});
    codegen_Parameters->documentations.push_back({"Color4Value",new Color4Verifier,Optional::No,"color4Value documentation"});
    codegen_Parameters->documentations.push_back({"OptionalColor4Value",new Color4Verifier,Optional::Yes,"optionalColor4Value documentation"});
    codegen_Parameters->documentations.push_back({"VectorColor4Value",new TableVerifier({{"*",new Color4Verifier,Optional::Yes, }})
,Optional::No,"vectorColor4Value documentation"});
    codegen_Parameters->documentations.push_back({"DateTimeValue",new DateTimeVerifier,Optional::No,"dateTime value documentation"});
    codegen_Parameters->documentations.push_back({"OptionalDateTimeValue",new DateTimeVerifier,Optional::Yes,"optional dateTime value documentation"});
    codegen_Parameters->documentations.push_back({"VectorDateTimeValue",new TableVerifier({{"*",new DateTimeVerifier,Optional::Yes, }})
,Optional::No,"vector dateTime value documentation"});
    codegen_Parameters->documentations.push_back({"OptionalVectorDateTimeValue",new TableVerifier({{"*",new DateTimeVerifier,Optional::Yes, }})
,Optional::Yes,"optional vector dateTime value documentation"});

    openspace::documentation::Documentation d = { "Attributes", std::move(id), std::move(codegen_Parameters->documentations) };
    return d;
}

} // namespace codegen

namespace codegen {
namespace internal {
template<typename T> void bakeTo(const ghoul::Dictionary&, std::string_view, T*) { static_assert(sizeof(T) == 0); }
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val);
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val);
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::map<std::string, T>* val);
void bakeTo(const ghoul::Dictionary& d, std::string_view key, float* val) { *val = static_cast<float>(d.value<double>(key)); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, int* val) { if (d.hasValue<double>(key)) { *val = static_cast<int>(d.value<double>(key)); } else if (d.hasValue<int>(key)) { *val = d.value<int>(key); } else { throw std::logic_error("Unexpected type"); } }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, bool* val) { *val = d.value<bool>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::string* val) { *val = d.value<std::string>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, ghoul::Dictionary* val) { *val = d.value<ghoul::Dictionary>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dvec3* val) { *val = d.value<glm::dvec3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::vec3* val) { *val = d.value<glm::dvec3>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::dvec4* val) { *val = d.value<glm::dvec4>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, glm::vec4* val) { *val = d.value<glm::dvec4>(key); }

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val) {
    if (d.hasKey(key)) {
        T v;
        bakeTo(d, key, &v);
        *val = v;
    }
    else {
        *val = std::nullopt;
    }
}

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val) {
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    // For the moment we need to make sure in here that all of the keys are sequential
    // since our TableVerifier doesn't really do that and we don't have a VectorVerifier
    // for a flat list (yet).  So you might have gotten a specification error from here
    // iff the Dictionary that was passed in contained keys other than a linear sequence
    // from 1 - dict.size()  [1 because Lua for some strange reason wants to start at the
    // wrong number]

    for (size_t i = 1; i <= dict.size(); ++i) {
        std::string k = std::to_string(i);
        if (!dict.hasKey(k)) {
            throw std::runtime_error("Could not find key '" + k + "' in the dictionary");
        }
    }    

    for (size_t i = 1; i <= dict.size(); ++i) {
        T v;
        bakeTo(dict, std::to_string(i), &v);
        val->push_back(std::move(v));
    }
}

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::map<std::string, T>* val) {
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    
    for (std::string_view k : dict.keys()) {
        T v;
        bakeTo(dict, k, &v);
        val->insert({ std::string(k), v });
    }
}

} // namespace internal

template <typename T> T bake(const ghoul::Dictionary&) { static_assert(sizeof(T) == 0); }

template <> Parameters bake<Parameters>(const ghoul::Dictionary& dict) {
    openspace::documentation::testSpecificationAndThrow(codegen::doc<Parameters>("Parameters"), dict, "Attributes");
    Parameters res;
    internal::bakeTo(dict, "KeyKey", &res.keyValue);
    internal::bakeTo(dict, "KeyKeyOptional", &res.keyValueOptional);
    internal::bakeTo(dict, "KeyKeyVector", &res.keyValueVector);
    internal::bakeTo(dict, "InRangeValueInt", &res.inRangeValueInt);
    internal::bakeTo(dict, "InRangeValueIntOptional", &res.inRangeValueIntOptional);
    internal::bakeTo(dict, "InRangeValueIntVector", &res.inRangeValueIntVector);
    internal::bakeTo(dict, "InRangeValueFloat", &res.inRangeValueFloat);
    internal::bakeTo(dict, "InRangeValueFloatOptional", &res.inRangeValueFloatOptional);
    internal::bakeTo(dict, "InRangeValueFloatVector", &res.inRangeValueFloatVector);
    internal::bakeTo(dict, "NotInRangeValueInt", &res.notInRangeValueInt);
    internal::bakeTo(dict, "NotInRangeValueIntOptional", &res.notInRangeValueIntOptional);
    internal::bakeTo(dict, "NotInRangeValueIntVector", &res.notInRangeValueIntVector);
    internal::bakeTo(dict, "NotInRangeValueFloat", &res.notInRangeValueFloat);
    internal::bakeTo(dict, "NotInRangeValueFloatOptional", &res.notInRangeValueFloatOptional);
    internal::bakeTo(dict, "NotInRangeValueFloatVector", &res.notInRangeValueFloatVector);
    internal::bakeTo(dict, "LessValueInt", &res.lessValueInt);
    internal::bakeTo(dict, "LessValueIntOptional", &res.lessValueIntOptional);
    internal::bakeTo(dict, "LessValueIntVector", &res.lessValueIntVector);
    internal::bakeTo(dict, "LessValueFloat", &res.lessValueFloat);
    internal::bakeTo(dict, "LessValueFloatOptional", &res.lessValueFloatOptional);
    internal::bakeTo(dict, "LessValueFloatVector", &res.lessValueFloatVector);
    internal::bakeTo(dict, "LessEqualValueInt", &res.lessEqualValueInt);
    internal::bakeTo(dict, "LessEqualValueIntOptional", &res.lessEqualValueIntOptional);
    internal::bakeTo(dict, "LessEqualValueIntVector", &res.lessEqualValueIntVector);
    internal::bakeTo(dict, "LessEqualValueFloat", &res.lessEqualValueFloat);
    internal::bakeTo(dict, "LessEqualValueFloatOptional", &res.lessEqualValueFloatOptional);
    internal::bakeTo(dict, "LessEqualValueFloatVector", &res.lessEqualValueFloatVector);
    internal::bakeTo(dict, "GreaterValueInt", &res.greaterValueInt);
    internal::bakeTo(dict, "GreaterValueIntOptional", &res.greaterValueIntOptional);
    internal::bakeTo(dict, "GreaterValueIntVector", &res.greaterValueIntVector);
    internal::bakeTo(dict, "GreaterValueFloat", &res.greaterValueFloat);
    internal::bakeTo(dict, "GreaterValueFloatOptional", &res.greaterValueFloatOptional);
    internal::bakeTo(dict, "GreaterValueFloatVector", &res.greaterValueFloatVector);
    internal::bakeTo(dict, "GreaterEqualValueInt", &res.greaterEqualValueInt);
    internal::bakeTo(dict, "GreaterEqualValueIntOptional", &res.greaterEqualValueIntOptional);
    internal::bakeTo(dict, "GreaterEqualValueIntVector", &res.greaterEqualValueIntVector);
    internal::bakeTo(dict, "GreaterEqualValueFloat", &res.greaterEqualValueFloat);
    internal::bakeTo(dict, "GreaterEqualValueFloatOptional", &res.greaterEqualValueFloatOptional);
    internal::bakeTo(dict, "GreaterEqualValueFloatVector", &res.greaterEqualValueFloatVector);
    internal::bakeTo(dict, "UnequalValueInt", &res.unequalValueInt);
    internal::bakeTo(dict, "UnequalValueIntOptional", &res.unequalValueIntOptional);
    internal::bakeTo(dict, "UnequalValueIntVector", &res.unequalValueIntVector);
    internal::bakeTo(dict, "UnequalValueFloat", &res.unequalValueFloat);
    internal::bakeTo(dict, "UnequalValueFloatOptional", &res.unequalValueFloatOptional);
    internal::bakeTo(dict, "UnequalValueFloatVector", &res.unequalValueFloatVector);
    internal::bakeTo(dict, "DescValue", &res.descValue);
    internal::bakeTo(dict, "InListValue1", &res.inListValue1);
    internal::bakeTo(dict, "InListValue1Optional", &res.inListValue1Optional);
    internal::bakeTo(dict, "InListValue1Vector", &res.inListValue1Vector);
    internal::bakeTo(dict, "InListValue2", &res.inListValue2);
    internal::bakeTo(dict, "InListValue2Optional", &res.inListValue2Optional);
    internal::bakeTo(dict, "InListValue2Vector", &res.inListValue2Vector);
    internal::bakeTo(dict, "UnequalValueString", &res.unequalValueString);
    internal::bakeTo(dict, "UnequalValueStringOptional", &res.unequalValueStringOptional);
    internal::bakeTo(dict, "UnequalValueStringVector", &res.unequalValueStringVector);
    internal::bakeTo(dict, "NotEmptyString", &res.notEmptyString);
    internal::bakeTo(dict, "NotEmptyStringOptional", &res.notEmptyStringOptional);
    internal::bakeTo(dict, "NotEmptyStringVector", &res.notEmptyStringVector);
    internal::bakeTo(dict, "NotEmptyStringOptionalVector", &res.notEmptyStringOptionalVector);
    internal::bakeTo(dict, "ReferenceValueOptional", &res.referenceValueOptional);
    internal::bakeTo(dict, "ReferenceValueVector", &res.referenceValueVector);
    internal::bakeTo(dict, "DictValue", &res.dictValue);
    internal::bakeTo(dict, "DictValueVector", &res.dictValueVector);
    internal::bakeTo(dict, "DictValueOptional", &res.dictValueOptional);
    internal::bakeTo(dict, "DictValueMap", &res.dictValueMap);
    internal::bakeTo(dict, "VectorDictValueMap", &res.vectorDictValueMap);
    internal::bakeTo(dict, "OptionalDictValueMap", &res.optionalDictValueMap);
    internal::bakeTo(dict, "OptionalVectorDictValueMap", &res.optionalVectorDictValueMap);
    internal::bakeTo(dict, "Annotation", &res.annotation);
    internal::bakeTo(dict, "AnnotationOptional", &res.annotationOptional);
    internal::bakeTo(dict, "AnnotationVector", &res.annotationVector);
    internal::bakeTo(dict, "Dcolor3Value", &res.dcolor3Value);
    internal::bakeTo(dict, "OptionalDcolor3Value", &res.optionalDcolor3Value);
    internal::bakeTo(dict, "VectorDcolor3Value", &res.vectorDcolor3Value);
    internal::bakeTo(dict, "Color3Value", &res.color3Value);
    internal::bakeTo(dict, "OptionalColor3Value", &res.optionalColor3Value);
    internal::bakeTo(dict, "VectorColor3Value", &res.vectorColor3Value);
    internal::bakeTo(dict, "Dcolor4Value", &res.dcolor4Value);
    internal::bakeTo(dict, "OptionalDcolor4Value", &res.optionalDcolor4Value);
    internal::bakeTo(dict, "VectorDcolor4Value", &res.vectorDcolor4Value);
    internal::bakeTo(dict, "Color4Value", &res.color4Value);
    internal::bakeTo(dict, "OptionalColor4Value", &res.optionalColor4Value);
    internal::bakeTo(dict, "VectorColor4Value", &res.vectorColor4Value);
    internal::bakeTo(dict, "DateTimeValue", &res.dateTimeValue);
    internal::bakeTo(dict, "OptionalDateTimeValue", &res.optionalDateTimeValue);
    internal::bakeTo(dict, "VectorDateTimeValue", &res.vectorDateTimeValue);
    internal::bakeTo(dict, "OptionalVectorDateTimeValue", &res.optionalVectorDateTimeValue);
    return res;
}

}// namespace codegen

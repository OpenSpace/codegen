// This file has been auto-generated by the codegen tool
//
// Do not change this file manually as any change will be automatically overwritten,
// instead change the struct tagged with "codegen::Dictionary" in the main file from which
// the code in this file was generated.
//
// If a compiler error brought you here, a struct tagged with "codegen::Dictionary"
// was changed without the codegen tool being run again.

namespace codegen {
template <typename T> openspace::documentation::Documentation doc() {
    static_assert(sizeof(T) == 0); // This should never be called
    return openspace::documentation::Documentation();
}
template <> openspace::documentation::Documentation doc<openspace::Substructs>() {
    using namespace openspace::documentation;
    TableVerifier* codegen_Parameters = new TableVerifier;
    TableVerifier* codegen_Parameters_A = new TableVerifier;
    codegen_Parameters_A->documentations.push_back({"Value",new IntVerifier,Optional::No,"A::value documentation"});
    TableVerifier* codegen_Parameters_B = new TableVerifier;
    codegen_Parameters_B->documentations.push_back({"Valval",new DoubleVerifier,Optional::No,"B::valval documentation"});
    TableVerifier* codegen_Parameters_C = new TableVerifier;
    codegen_Parameters_C->documentations.push_back({"Eulav",new StringVerifier,Optional::No,"C::eulav documentation"});
    codegen_Parameters_C->documentations.push_back({"Lavlav",new BoolVerifier,Optional::No,"C::lavlav documentation"});
    codegen_Parameters->documentations.push_back({"StructAValue",codegen_Parameters_A,Optional::No,"variable structAValue documentation"});
    codegen_Parameters->documentations.push_back({"StructBValue",codegen_Parameters_B,Optional::Yes,"variable structBValue documentation"});
    codegen_Parameters->documentations.push_back({"StructCValue",new TableVerifier({{"*",codegen_Parameters_C,Optional::Yes, "struct C documentation"}})
,Optional::No,"variable structCValue documentation"});

    openspace::documentation::Documentation d = { "Substructs", "Substructs", std::move(codegen_Parameters->documentations) };
    delete codegen_Parameters;
    return d;
}
} // namespace codegen


namespace codegen {
namespace internal {
template<typename T> void bakeTo(const ghoul::Dictionary&, std::string_view, T*) { static_assert(sizeof(T) == 0); } // This should never be called
void bakeTo(const ghoul::Dictionary& d, std::string_view key, bool* val) { *val = d.value<bool>(key); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, float* val) { *val = static_cast<float>(d.value<double>(key)); }
void bakeTo(const ghoul::Dictionary& d, std::string_view key, int* val) { *val = static_cast<int>(d.value<double>(key)); }
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val);
void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::string* val) { *val = d.value<std::string>(key); }
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val);
template <> void bakeTo<Parameters::A>(const ghoul::Dictionary& d, std::string_view key, Parameters::A* val) {
    Parameters::A& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Value", &res.value);
}
template <> void bakeTo<Parameters::B>(const ghoul::Dictionary& d, std::string_view key, Parameters::B* val) {
    Parameters::B& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Valval", &res.valval);
}
template <> void bakeTo<Parameters::C>(const ghoul::Dictionary& d, std::string_view key, Parameters::C* val) {
    Parameters::C& res = *val;
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    internal::bakeTo(dict, "Eulav", &res.eulav);
    internal::bakeTo(dict, "Lavlav", &res.lavlav);
}

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val) {
    if (d.hasKey(key)) {
        T v;
        bakeTo(d, key, &v);
        *val = v;
    }
    else *val = std::nullopt;
}

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val) {
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    std::vector<std::string_view> keys = dict.keys();
    val->reserve(keys.size());
    for (size_t i = 0; i < dict.size(); ++i) {
        T v;
        bakeTo(dict, keys[i], &v);
        val->push_back(std::move(v));
    }
}

} // namespace internal

template <typename T> T bake(const ghoul::Dictionary&) { static_assert(sizeof(T) == 0); }
template <> Parameters bake<Parameters>(const ghoul::Dictionary& dict) {
    openspace::documentation::testSpecificationAndThrow(codegen::doc<openspace::Substructs>(), dict, "Substructs");
    Parameters res;
    internal::bakeTo(dict, "StructAValue", &res.structAValue);
    internal::bakeTo(dict, "StructBValue", &res.structBValue);
    internal::bakeTo(dict, "StructCValue", &res.structCValue);
    return res;
}
} // namespace codegen

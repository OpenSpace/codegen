// This file has been auto-generated by the codegen tool
//
// Do not change this file manually as any change will be automatically overwritten,
// instead change the struct tagged with "codegen::Dictionary" in the main file from which
// the code in this file was generated.
//
// If a compiler error brought you here, a struct tagged with "codegen::Dictionary"
// was changed without the codegen tool being run again.

namespace codegen {
template <typename T> openspace::documentation::Documentation doc() {
    static_assert(sizeof(T) == 0); // This should never be called
    return openspace::documentation::Documentation();
}
template <> openspace::documentation::Documentation doc<openspace::Enums>() {
    using namespace openspace::documentation;
    TableVerifier* codegen_Parameters = new TableVerifier;
    StringInListVerifier* codegen_Parameters_A = new StringInListVerifier({"Value1","value2","Value3"});
    StringInListVerifier* codegen_Parameters_B = new StringInListVerifier({"Value1","value2","Value3"});
    StringInListVerifier* codegen_Parameters_C = new StringInListVerifier({"Value1","value2","Value3"});
    codegen_Parameters->documentations.push_back({"EnumAValue",codegen_Parameters_A,Optional::No,"variable enumAValue documentation"});
    codegen_Parameters->documentations.push_back({"EnumBValue",codegen_Parameters_B,Optional::Yes,"variable enumBValue documentation"});
    codegen_Parameters->documentations.push_back({"EnumCValue",new TableVerifier({{"*",codegen_Parameters_C,Optional::Yes, "enum C documentation"}})
,Optional::No,"variable enumCValue documentation"});

    openspace::documentation::Documentation d = { "Enums", "Enums", std::move(codegen_Parameters->documentations) };
    delete codegen_Parameters;
    return d;
}
} // namespace codegen


namespace codegen {
namespace internal {
template<typename T> void bakeTo(const ghoul::Dictionary&, std::string_view, T*) { static_assert(sizeof(T) == 0); } // This should never be called
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val);
template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val);
void bakeTo(const ghoul::Dictionary& d, std::string_view key, Parameters::A* val) {
    std::string v = d.value<std::string>(key);
    if (v == "Value1") { *val = Parameters::A::Value1; }
    if (v == "value2") { *val = Parameters::A::value2; }
    if (v == "Value3") { *val = Parameters::A::Value3; }
}
void bakeTo(const ghoul::Dictionary& d, std::string_view key, Parameters::B* val) {
    std::string v = d.value<std::string>(key);
    if (v == "Value1") { *val = Parameters::B::Value1; }
    if (v == "value2") { *val = Parameters::B::value2; }
    if (v == "Value3") { *val = Parameters::B::Value3; }
}
void bakeTo(const ghoul::Dictionary& d, std::string_view key, Parameters::C* val) {
    std::string v = d.value<std::string>(key);
    if (v == "Value1") { *val = Parameters::C::Value1; }
    if (v == "value2") { *val = Parameters::C::value2; }
    if (v == "Value3") { *val = Parameters::C::Value3; }
}

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::optional<T>* val) {
    if (d.hasKey(key)) {
        T v;
        bakeTo(d, key, &v);
        *val = v;
    }
    else *val = std::nullopt;
}

template<typename T> void bakeTo(const ghoul::Dictionary& d, std::string_view key, std::vector<T>* val) {
    ghoul::Dictionary dict = d.value<ghoul::Dictionary>(key);
    std::vector<std::string_view> keys = dict.keys();
    val->reserve(keys.size());
    for (size_t i = 0; i < dict.size(); ++i) {
        T v;
        bakeTo(dict, keys[i], &v);
        val->push_back(std::move(v));
    }
}

} // namespace internal

template <typename T> T bake(const ghoul::Dictionary&) { static_assert(sizeof(T) == 0); }
template <> Parameters bake<Parameters>(const ghoul::Dictionary& dict) {
    openspace::documentation::testSpecificationAndThrow(codegen::doc<openspace::Enums>(), dict, "Enums");
    Parameters res;
    internal::bakeTo(dict, "EnumAValue", &res.enumAValue);
    internal::bakeTo(dict, "EnumBValue", &res.enumBValue);
    internal::bakeTo(dict, "EnumCValue", &res.enumCValue);
    return res;
}
} // namespace codegen
